GET http://localhost:5001/api/cves?page=1&limit=10



// const SYNC_INTERVAL_MS = 24 * 60 * 60 * 1000;
// setInterval(fetchAndSaveCVEData, SYNC_INTERVAL_MS);
// fetchAndSaveCVEData();

// app.get("/cve", async (req, res) => {
//   try {
//     const cves = await CVE.find();
//     res.json({ success: true, cves });
//   } catch (error) {
//     console.error("Error fetching CVE data:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });

// app.get("/cves/:cveId", async (req, res) => {
//   try {
//     const { cveId } = req.params;
//     console.log(cveId)
//     const cve = await CVE.findOne({ id: cveId });
//     if (!cve) {
//       return res.status(404).json({ success: false, message: "CVE not found" });
//     }
//     res.json({ success: true, cve });
//   } catch (error) {
//     console.error("Error fetching CVE data by ID:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });

// app.get("/cves/year/:year", async (req, res) => {
//   try {
//     const { year } = req.params;
//     const cves = await CVE.find({
//       published: {
//         $gte: new Date(`${year}-01-01`),
//         $lt: new Date(`${year}-12-31`),
//       },
//     });
//     res.json({ success: true, cves });
//   } catch (error) {
//     console.error("Error fetching CVE data by year:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });

// // API endpoint to fetch CVE details based on CVE score
// app.get("/cves/score/:score", async (req, res) => {
//   try {
//     const { score } = req.params;
//     const cves = await CVE.find({
//       $or: [
//         { "metrics.cvssMetricV2.cvssData.baseScore": score },
//         { "metrics.cvssMetricV3.cvssData.baseScore": score },
//       ],
//     });
//     res.json({ success: true, cves });
//   } catch (error) {
//     console.error("Error fetching CVE data by score:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });

// // API endpoint to fetch CVE details based on last modified date within N days
// app.get("/cves/modified/:days", async (req, res) => {
//   try {
//     const { days } = req.params;
//     const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
//     const cves = await CVE.find({ lastModified: { $gte: cutoffDate } });
//     res.json({ success: true, cves });
//   } catch (error) {
//     console.error(
//       "Error fetching CVE data by last modified date:",
//       error.message
//     );
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });

// app.get("/cves/sort/:sortBy", async (req, res) => {
//   try {
//     let { sortBy } = req.params;
//     let sortOption = {};
//     console.log(sortBy)
//     // Check if sortBy parameter is provided and valid
//     if (sortBy === 'published' || sortBy === 'lastModified') {
//       sortOption[sortBy] = 1; // Sort in ascending order
//     } else {
//       // Default sorting by 'published' date if sortBy parameter is not provided or invalid
//       sortOption['published'] = 1;
//     }

//     const cves = await CVE.find().sort(sortOption);
//     console.log(cves)
//     res.json({ success: true});
//   } catch (error) {
//     console.error("Error fetching CVE data:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// });
// app.get('/cves', paginatedResults(CVE), (req, res) => {
//   res.json(res.paginatedResults)
// })
// app.get('/totalcves', async (req, res) => {
//   try {
//     const cves = await CVE.find();
//     res.json({ success: true, cves: cves.length});
//   } catch (error) {
//     console.error("Error fetching CVE data:", error.message);
//     res.status(500).json({ success: false, message: "Internal server error" });
//   }
// } )

// function paginatedResults(model) {
//   return async (req, res, next) => {
//     const page = parseInt(req.query.page)
//     const limit = parseInt(req.query.limit)

//     const startIndex = (page - 1) * limit
//     const endIndex = page * limit

//     const results = {}

//     if (endIndex < await model.countDocuments().exec()) {
//       results.next = {
//         page: page + 1,
//         limit: limit
//       }
//     }

//     if (startIndex > 0) {
//       results.previous = {
//         page: page - 1,
//         limit: limit
//       }
//     }
//     try {
//       results.results = await CVE.find().limit(limit).skip(startIndex).exec()
//       res.paginatedResults = results
//       next()
//     } catch (e) {
//       res.status(500).json({ message: e.message })
//     }
//   }
// }
